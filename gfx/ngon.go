// draws a convex n-gon
package main

import (
	"image/color"
	"log"
	"math"
	"math/rand"
	"os"
	"runtime"
	"time"

	"github.com/qeedquan/go-media/image/chroma"
	"github.com/qeedquan/go-media/math/f64"
	"github.com/qeedquan/go-media/sdl"
	"github.com/qeedquan/go-media/sdl/sdlgfx"
)

var (
	window   *sdl.Window
	renderer *sdl.Renderer
	ngons    []ngon
)

func main() {
	runtime.LockOSThread()
	rand.Seed(time.Now().UnixNano())
	initSDL()
	reset()
	for {
		event()
		update()
		blit()
	}
}

func initSDL() {
	err := sdl.Init(sdl.INIT_VIDEO)
	ck(err)

	window, renderer, err = sdl.CreateWindowAndRenderer(1024, 768, sdl.WINDOW_RESIZABLE)
	ck(err)

	window.SetTitle("N-Gon")
}

func reset() {
	N := 16
	ngons = ngons[:0]
	for i := 0; i < N; i++ {
		ngons = append(ngons, rgen())
	}
}

func ck(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

func event() {
	for {
		ev := sdl.PollEvent()
		if ev == nil {
			break
		}
		switch ev := ev.(type) {
		case sdl.QuitEvent:
			os.Exit(0)
		case sdl.KeyDownEvent:
			switch ev.Sym {
			case sdl.K_ESCAPE:
				os.Exit(0)
			case sdl.K_SPACE:
				reset()
			}
		}
	}
}

func update() {
	for i := range ngons {
		ngons[i].orientation += 0.01
		if ngons[i].orientation >= 2*math.Pi {
			ngons[i].orientation -= 2 * math.Pi
		}
	}
}

func blit() {
	renderer.SetDrawColor(color.RGBA{100, 100, 100, 255})
	renderer.Clear()
	for i := range ngons {
		ngons[i].Blit()
	}
	renderer.Present()
}

type ngon struct {
	bounds      f64.Rectangle
	points      []f64.Vec2
	origin      f64.Vec2
	orientation float64
	radius      float64
	col         color.RGBA
	icol        color.RGBA
	fill        bool
}

// a convex polygon is generated by generating points on a circle using
// separated by a fixed angle determined by how many sides it has
func rgen() ngon {
	w, _, _ := renderer.OutputSize()
	n := 1 + rand.Intn(20)
	r := 0.05 + rand.Float64()*0.1*float64(w)
	b := f64.Rectangle{Min: f64.Vec2{1e6, 1e6}, Max: f64.Vec2{-1e6, -1e6}}
	var p []f64.Vec2
	for i := 0; i < n; i++ {
		x := r * math.Sin(float64(i)/float64(n)*2*math.Pi)
		y := r * math.Cos(float64(i)/float64(n)*2*math.Pi)
		b.Min.X = math.Min(b.Min.X, x)
		b.Min.Y = math.Min(b.Min.Y, y)
		b.Max.X = math.Max(b.Max.X, x)
		b.Max.Y = math.Max(b.Max.X, y)
		p = append(p, f64.Vec2{x, y})
	}

	b.Min.X *= 2
	b.Min.Y *= 2
	b.Max.X *= 2
	b.Max.Y *= 2

	c := chroma.RandRGBA()
	ic := chroma.RandRGBA()
	c.A, ic.A = 127, 127
	return ngon{
		bounds:      b,
		points:      p,
		origin:      rv2(),
		orientation: rand.Float64() * 2 * math.Pi,
		radius:      r,
		col:         c,
		icol:        ic,
		fill:        rand.Float64() > 0.5,
	}
}

func rv2() f64.Vec2 {
	w, h, _ := renderer.OutputSize()
	return f64.Vec2{float64(w) * rand.Float64(), float64(h) * rand.Float64()}
}

func (n *ngon) Blit() {
	R := f64.Mat2{}
	R.Rotate(n.orientation)

	M := R

	for i := range n.points {
		p := n.points[i]
		q := n.points[(i+1)%len(n.points)]

		p = M.Transform(p)
		q = M.Transform(q)

		p = p.Add(n.origin)
		q = q.Add(n.origin)

		sdlgfx.ThickLine(renderer, int(p.X), int(p.Y), int(q.X), int(q.Y), 3, color.RGBA{127, 127, 127, 127})
		sdlgfx.FilledCircle(renderer, int(q.X), int(q.Y), 5, n.col)
	}

	if n.fill {
		b := n.bounds
		for y := int(b.Min.Y); y < int(b.Max.Y); y++ {
			for x := int(b.Min.X); x < int(b.Max.X); x++ {
				if n.inside(f64.Vec2{float64(x), float64(y)}) {
					p := f64.Vec2{float64(x), float64(y)}.Add(n.origin)
					renderer.SetDrawColor(n.icol)
					renderer.DrawPoint(int(p.X), int(p.Y))
				}
			}
		}
	}
}

// a point is inside a polygon if the point is considered on the left of all the lines
// that connects to make a polygon, we can determine this using the determinant
func (n *ngon) inside(p f64.Vec2) bool {
	R := f64.Mat2{}
	R.Rotate(n.orientation)

	M := R
	for i := range n.points {
		a := n.points[i]
		b := n.points[(i+1)%len(n.points)]

		a = M.Transform(a)
		b = M.Transform(b)

		sign := (b.X-a.X)*(p.Y-a.Y) - (b.Y-a.Y)*(p.X-a.X)
		if sign > 0 {
			return false
		}
	}
	return true
}
