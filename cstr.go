// based on linux bin2hex
package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"os"
	"strings"
)

var (
	spaces   = flag.Int("s", 4, "number of spaces a tab represents")
	useTab   = flag.Bool("t", true, "don't convert tab into spaces")
	useInt   = flag.Bool("i", false, "use int type for length")
	useArray = flag.Bool("a", true, "output array of strings instead of a long string")
)

func main() {
	flag.Parse()
	if flag.NArg() < 1 {
		usage()
	}

	fmt.Printf("/* automatically generated by cstr */\n")
	if !*useInt {
		fmt.Println("#include <stddef.h>\n")
	}

	r := bufio.NewReader(os.Stdin)
	if *useArray {
		printArray(r)
	} else {
		printString(r)
	}
}

func printArray(r *bufio.Reader) {
	fmt.Printf("const char *%s[] = {\n", flag.Arg(0))
	for {
		line, err := fgetln(r)
		if err != nil {
			break
		}
		fmt.Printf("\t%q,\n", line)
	}
	fmt.Printf("\tNULL,\n")
	fmt.Printf("};\n")
}

func printString(r *bufio.Reader) {
	fmt.Printf("const char %s[] = {\n", flag.Arg(0))
	i := uint64(0)
	for {
		line, err := fgetln(r)
		if err != nil {
			break
		}
		i += uint64(len(line))
		fmt.Printf("\t%q\n", line)
	}

	typ := "size_t"
	if *useInt {
		typ = "int"
	}
	fmt.Printf("\n};\n%s %s_len = %d;\n", typ, flag.Arg(0), i)
}

func usage() {
	fmt.Fprintln(os.Stderr, "usage: name")
	flag.PrintDefaults()
	os.Exit(1)
}

func fgetln(r *bufio.Reader) (string, error) {
	b := new(bytes.Buffer)
	for {
		r, _, err := r.ReadRune()
		if err != nil {
			return b.String(), err
		}
		if !*useTab {
			if r == '\t' {
				b.WriteString(strings.Repeat(" ", *spaces))
				continue
			}
		}
		b.WriteRune(r)
		if r == '\n' {
			break
		}
	}
	return b.String(), nil
}
